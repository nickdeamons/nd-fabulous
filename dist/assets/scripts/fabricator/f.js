/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/scripts/fabricator/fabricator.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/scripts/fabricator/fabricator.js":
/*!**********************************************!*\
  !*** ./src/scripts/fabricator/fabricator.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _this = this;\n\n__webpack_require__(/*! ./prism */ \"./src/scripts/fabricator/prism.js\");\n\n/**\n * Global `fabricator` object\n * @namespace\n */\nconst fabricator = window.fabricator = {};\n\n/**\n * Default options\n * @type {Object}\n */\nfabricator.options = {\n  toggles: {\n    labels: true,\n    notes: true,\n    code: false\n  },\n  menu: false,\n  mq: '(min-width: 60em)'\n};\n\n// open menu by default if large screen\nfabricator.options.menu = window.matchMedia(fabricator.options.mq).matches;\n\n/**\n * Feature detection\n * @type {Object}\n */\nfabricator.test = {};\n\n// test for sessionStorage\nfabricator.test.sessionStorage = (() => {\n  const test = '_f';\n  try {\n    sessionStorage.setItem(test, test);\n    sessionStorage.removeItem(test);\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();\n\n// create storage object if it doesn't exist; store options\nif (fabricator.test.sessionStorage) {\n  sessionStorage.fabricator = sessionStorage.fabricator || JSON.stringify(fabricator.options);\n}\n\n/**\n * Cache DOM\n * @type {Object}\n */\nfabricator.dom = {\n  root: document.querySelector('html'),\n  primaryMenu: document.querySelector('.f-menu'),\n  menuItems: document.querySelectorAll('.f-menu li a'),\n  menuToggle: document.querySelector('.f-menu-toggle')\n};\n\n/**\n * Get current option values from session storage\n * @return {Object}\n */\nfabricator.getOptions = () => {\n  return fabricator.test.sessionStorage ? JSON.parse(sessionStorage.fabricator) : fabricator.options;\n};\n\n/**\n * Build color chips\n */\nfabricator.buildColorChips = () => {\n\n  const chips = document.querySelectorAll('.f-color-chip');\n\n  for (let i = chips.length - 1; i >= 0; i--) {\n    const color = chips[i].querySelector('.f-color-chip__color').innerHTML;\n    chips[i].style.borderTopColor = color;\n    chips[i].style.borderBottomColor = color;\n  }\n\n  return fabricator;\n};\n\n/**\n * Add `f-active` class to active menu item\n */\nfabricator.setActiveItem = () => {\n\n  /**\n   * Match the window location with the menu item, set menu item as active\n   */\n  const setActive = () => {\n\n    // get current file and hash without first slash\n    const loc = window.location.pathname + window.location.hash;\n    const current = loc.replace(/(^\\/)([^#]+)?(#[\\w\\-\\.]+)?$/ig, (match, slash, file, hash) => {\n      return (file || '') + (hash || '').split('.')[0];\n    }) || 'index.html';\n\n    // find the current section in the items array\n    for (let i = fabricator.dom.menuItems.length - 1; i >= 0; i--) {\n\n      const item = fabricator.dom.menuItems[i];\n\n      // get item href without first slash\n      const href = item.getAttribute('href').replace(/^\\//g, '');\n\n      if (href === current) {\n        item.classList.add('f-active');\n      } else {\n        item.classList.remove('f-active');\n      }\n    }\n  };\n\n  window.addEventListener('hashchange', setActive);\n\n  setActive();\n\n  return fabricator;\n};\n\n/**\n * Click handler to primary menu toggle\n * @return {Object} fabricator\n */\nfabricator.menuToggle = () => {\n\n  // shortcut menu DOM\n  const toggle = fabricator.dom.menuToggle;\n  const options = fabricator.getOptions();\n\n  // toggle classes on certain elements\n  const toggleClasses = () => {\n    options.menu = !fabricator.dom.root.classList.contains('f-menu-active');\n    fabricator.dom.root.classList.toggle('f-menu-active');\n\n    if (fabricator.test.sessionStorage) {\n      sessionStorage.setItem('fabricator', JSON.stringify(options));\n    }\n  };\n\n  // toggle classes on ctrl + m press\n  document.onkeydown = e => {\n    if (e.ctrlKey && e.keyCode === 'M'.charCodeAt(0)) {\n      toggleClasses();\n    }\n  };\n\n  // toggle classes on click\n  toggle.addEventListener('click', () => {\n    toggleClasses();\n  });\n\n  // close menu when clicking on item (for collapsed menu view)\n  const closeMenu = () => {\n    if (!window.matchMedia(fabricator.options.mq).matches) {\n      toggleClasses();\n    }\n  };\n\n  for (let i = 0; i < fabricator.dom.menuItems.length; i++) {\n    fabricator.dom.menuItems[i].addEventListener('click', closeMenu);\n  }\n\n  return fabricator;\n};\n\n/**\n * Handler for preview and code toggles\n * @return {Object} fabricator\n */\nfabricator.allItemsToggles = () => {\n\n  const itemCache = {\n    labels: document.querySelectorAll('[data-f-toggle=\"labels\"]'),\n    notes: document.querySelectorAll('[data-f-toggle=\"notes\"]'),\n    code: document.querySelectorAll('[data-f-toggle=\"code\"]')\n  };\n\n  const toggleAllControls = document.querySelectorAll('.f-controls [data-f-toggle-control]');\n  const options = fabricator.getOptions();\n\n  // toggle all\n  const toggleAllItems = (type, value) => {\n\n    const button = document.querySelector(`.f-controls [data-f-toggle-control=${type}]`);\n    const items = itemCache[type];\n\n    for (let i = 0; i < items.length; i++) {\n      if (value) {\n        items[i].classList.remove('f-item-hidden');\n      } else {\n        items[i].classList.add('f-item-hidden');\n      }\n    }\n\n    // toggle styles\n    if (value) {\n      button.classList.add('f-active');\n    } else {\n      button.classList.remove('f-active');\n    }\n\n    // update options\n    options.toggles[type] = value;\n\n    if (fabricator.test.sessionStorage) {\n      sessionStorage.setItem('fabricator', JSON.stringify(options));\n    }\n  };\n\n  for (let i = 0; i < toggleAllControls.length; i++) {\n\n    toggleAllControls[i].addEventListener('click', e => {\n\n      // extract info from target node\n      const type = e.currentTarget.getAttribute('data-f-toggle-control');\n      const value = e.currentTarget.className.indexOf('f-active') < 0;\n\n      // toggle the items\n      toggleAllItems(type, value);\n    });\n  }\n\n  // persist toggle options from page to page\n  Object.keys(options.toggles).forEach(key => {\n    toggleAllItems(key, options.toggles[key]);\n  });\n\n  return fabricator;\n};\n\n/**\n * Handler for single item code toggling\n */\nfabricator.singleItemToggle = () => {\n\n  const itemToggleSingle = document.querySelectorAll('.f-item-group [data-f-toggle-control]');\n\n  // toggle single\n  const toggleSingleItemCode = e => {\n    const group = e.currentTarget.parentNode.parentNode.parentNode;\n    const type = e.currentTarget.getAttribute('data-f-toggle-control');\n    group.querySelector(`[data-f-toggle=${type}]`).classList.toggle('f-item-hidden');\n  };\n\n  for (let i = 0; i < itemToggleSingle.length; i++) {\n    itemToggleSingle[i].addEventListener('click', toggleSingleItemCode);\n  }\n\n  return fabricator;\n};\n\n/**\n * Automatically select code when code block is clicked\n */\nfabricator.bindCodeAutoSelect = () => {\n\n  const codeBlocks = document.querySelectorAll('.f-item-code');\n\n  const select = block => {\n    const selection = window.getSelection();\n    const range = document.createRange();\n    range.selectNodeContents(block.querySelector('code'));\n    selection.removeAllRanges();\n    selection.addRange(range);\n  };\n\n  for (let i = codeBlocks.length - 1; i >= 0; i--) {\n    codeBlocks[i].addEventListener('click', select.bind(_this, codeBlocks[i]));\n  }\n};\n\n/**\n * Open/Close menu based on session var.\n * Also attach a media query listener to close the menu when resizing to smaller screen.\n */\nfabricator.setInitialMenuState = () => {\n\n  // root element\n  const root = document.querySelector('html');\n\n  const mq = window.matchMedia(fabricator.options.mq);\n\n  // if small screen\n  const mediaChangeHandler = list => {\n    if (!list.matches) {\n      root.classList.remove('f-menu-active');\n    } else {\n      if (fabricator.getOptions().menu) {\n        root.classList.add('f-menu-active');\n      } else {\n        root.classList.remove('f-menu-active');\n      }\n    }\n  };\n\n  mq.addListener(mediaChangeHandler);\n  mediaChangeHandler(mq);\n\n  return fabricator;\n};\n\n/**\n * Initialization\n */\nfabricator.setInitialMenuState().menuToggle().allItemsToggles().singleItemToggle().buildColorChips().setActiveItem().bindCodeAutoSelect();\n\n//# sourceURL=webpack:///./src/scripts/fabricator/fabricator.js?");

/***/ }),

/***/ "./src/scripts/fabricator/prism.js":
/*!*****************************************!*\
  !*** ./src/scripts/fabricator/prism.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* http://prismjs.com/download.html?themes=prism&languages=markup+css+clike+javascript */\nself = typeof window !== 'undefined' ? window // if in browser\n: typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self // if in worker\n: {} // if in node js\n;\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = function () {\n\n\t// Private helper vars\n\tvar lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\n\tvar _ = self.Prism = {\n\t\tutil: {\n\t\t\tencode: function (tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (_.util.type(tokens) === 'Array') {\n\t\t\t\t\treturn tokens.map(_.util.encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n\t\t\t},\n\n\t\t\t// Deep clone a language definition (e.g. to extend it)\n\t\t\tclone: function (o) {\n\t\t\t\tvar type = _.util.type(o);\n\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tvar clone = {};\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn clone;\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\treturn o.map(function (v) {\n\t\t\t\t\t\t\treturn _.util.clone(v);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn o;\n\t\t\t}\n\t\t},\n\n\t\tlanguages: {\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n    * Insert a token before another token in a language literal\n    * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n    * we cannot just provide an object, we need anobject and a key.\n    * @param inside The key (or language id) of the parent\n    * @param before The key to insert before. If not provided, the function appends instead.\n    * @param insert Object with the key/value pairs to insert\n    * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n    */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || _.languages;\n\t\t\t\tvar grammar = root[inside];\n\n\t\t\t\tif (arguments.length == 2) {\n\t\t\t\t\tinsert = arguments[1];\n\n\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn grammar;\n\t\t\t\t}\n\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === root[inside] && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn root[inside] = ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function (o, callback, type) {\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tif (_.util.type(o[i]) === 'Object') {\n\t\t\t\t\t\t\t_.languages.DFS(o[i], callback);\n\t\t\t\t\t\t} else if (_.util.type(o[i]) === 'Array') {\n\t\t\t\t\t\t\t_.languages.DFS(o[i], callback, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\thighlightAll: function (async, callback) {\n\t\t\tvar elements = document.querySelectorAll('code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code');\n\n\t\t\tfor (var i = 0, element; element = elements[i++];) {\n\t\t\t\t_.highlightElement(element, async === true, callback);\n\t\t\t}\n\t\t},\n\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language,\n\t\t\t    grammar,\n\t\t\t    parent = element;\n\n\t\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\n\t\t\tif (parent) {\n\t\t\t\tlanguage = (parent.className.match(lang) || [, ''])[1];\n\t\t\t\tgrammar = _.languages[language];\n\t\t\t}\n\n\t\t\tif (!grammar) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set language on the element, if not present\n\t\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tparent = element.parentNode;\n\n\t\t\tif (/pre/i.test(parent.nodeName)) {\n\t\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tif (!code) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcode = code.replace(/^(?:\\r?\\n|\\r)/, '');\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (async && self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tenv.highlightedCode = Token.stringify(JSON.parse(evt.data), language);\n\n\t\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\tcallback && callback.call(element);\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t}\n\t\t},\n\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar tokens = _.tokenize(text, grammar);\n\t\t\treturn Token.stringify(_.util.encode(tokens), language);\n\t\t},\n\n\t\ttokenize: function (text, grammar, language) {\n\t\t\tvar Token = _.Token;\n\n\t\t\tvar strarr = [text];\n\n\t\t\tvar rest = grammar.rest;\n\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\ttokenloop: for (var token in grammar) {\n\t\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar patterns = grammar[token];\n\t\t\t\tpatterns = _.util.type(patterns) === \"Array\" ? patterns : [patterns];\n\n\t\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\t\tvar pattern = patterns[j],\n\t\t\t\t\t    inside = pattern.inside,\n\t\t\t\t\t    lookbehind = !!pattern.lookbehind,\n\t\t\t\t\t    lookbehindLength = 0,\n\t\t\t\t\t    alias = pattern.alias;\n\n\t\t\t\t\tpattern = pattern.pattern || pattern;\n\n\t\t\t\t\tfor (var i = 0; i < strarr.length; i++) {\n\t\t\t\t\t\t// Don’t cache length as it changes during the loop\n\n\t\t\t\t\t\tvar str = strarr[i];\n\n\t\t\t\t\t\tif (strarr.length > text.length) {\n\t\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\t\tbreak tokenloop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpattern.lastIndex = 0;\n\n\t\t\t\t\t\tvar match = pattern.exec(str);\n\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tif (lookbehind) {\n\t\t\t\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar from = match.index - 1 + lookbehindLength,\n\t\t\t\t\t\t\t    match = match[0].slice(lookbehindLength),\n\t\t\t\t\t\t\t    len = match.length,\n\t\t\t\t\t\t\t    to = from + len,\n\t\t\t\t\t\t\t    before = str.slice(0, from + 1),\n\t\t\t\t\t\t\t    after = str.slice(to + 1);\n\n\t\t\t\t\t\t\tvar args = [i, 1];\n\n\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\targs.push(before);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(match, inside) : match, alias);\n\n\t\t\t\t\t\t\targs.push(wrapped);\n\n\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\targs.push(after);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn strarr;\n\t\t},\n\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; callback = callbacks[i++];) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar Token = _.Token = function (type, content, alias) {\n\t\tthis.type = type;\n\t\tthis.content = content;\n\t\tthis.alias = alias;\n\t};\n\n\tToken.stringify = function (o, language, parent) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\n\t\tif (_.util.type(o) === 'Array') {\n\t\t\treturn o.map(function (element) {\n\t\t\t\treturn Token.stringify(element, language, o);\n\t\t\t}).join('');\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: Token.stringify(o.content, language, parent),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language,\n\t\t\tparent: parent\n\t\t};\n\n\t\tif (env.type == 'comment') {\n\t\t\tenv.attributes['spellcheck'] = 'true';\n\t\t}\n\n\t\tif (o.alias) {\n\t\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += name + '=\"' + (env.attributes[name] || '') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\tif (!self.document) {\n\t\tif (!self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn self.Prism;\n\t\t}\n\t\t// In worker\n\t\tself.addEventListener('message', function (evt) {\n\t\t\tvar message = JSON.parse(evt.data),\n\t\t\t    lang = message.language,\n\t\t\t    code = message.code;\n\n\t\t\tself.postMessage(JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang]))));\n\t\t\tself.close();\n\t\t}, false);\n\n\t\treturn self.Prism;\n\t}\n\n\t// Get current script and highlight\n\tvar script = document.getElementsByTagName('script');\n\n\tscript = script[script.length - 1];\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\n\t\t}\n\t}\n\n\treturn self.Prism;\n}();\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n;\nPrism.languages.markup = {\n\t'comment': /<!--[\\w\\W]*?-->/,\n\t'prolog': /<\\?.+?\\?>/,\n\t'doctype': /<!DOCTYPE.+?>/,\n\t'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n\t'tag': {\n\t\tpattern: /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/i,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[\\w:-]+/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[\\w-]+?:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /=|>|\"/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[\\w:-]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[\\w-]+?:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': /&#?[\\da-z]{1,8};/i\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n;\nPrism.languages.css = {\n\t'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n\t'atrule': {\n\t\tpattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n\t\tinside: {\n\t\t\t'punctuation': /[;:]/\n\t\t}\n\t},\n\t'url': /url\\((?:([\"'])(\\\\\\n|\\\\?.)*?\\1|.*?)\\)/i,\n\t'selector': /[^\\{\\}\\s][^\\{\\};]*(?=\\s*\\{)/,\n\t'string': /(\"|')(\\\\\\n|\\\\?.)*?\\1/,\n\t'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n\t'important': /\\B!important\\b/i,\n\t'punctuation': /[\\{\\};:]/,\n\t'function': /[-a-z0-9]+(?=\\()/i\n};\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'style': {\n\t\t\tpattern: /<style[\\w\\W]*?>[\\w\\W]*?<\\/style>/i,\n\t\t\tinside: {\n\t\t\t\t'tag': {\n\t\t\t\t\tpattern: /<style[\\w\\W]*?>|<\\/style>/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.css\n\t\t\t},\n\t\t\talias: 'language-css'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'attr-value', {\n\t\t'style-attr': {\n\t\t\tpattern: /\\s*style=(\"|').*?\\1/i,\n\t\t\tinside: {\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /^\\s*style/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\t'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /.+/i,\n\t\t\t\t\tinside: Prism.languages.css\n\t\t\t\t}\n\t\t\t},\n\t\t\talias: 'language-css'\n\t\t}\n\t}, Prism.languages.markup.tag);\n};\nPrism.languages.clike = {\n\t'comment': [{\n\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\tlookbehind: true\n\t}, {\n\t\tpattern: /(^|[^\\\\:])\\/\\/.+/,\n\t\tlookbehind: true\n\t}],\n\t'string': /(\"|')(\\\\\\n|\\\\?.)*?\\1/,\n\t'class-name': {\n\t\tpattern: /((?:(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\tpunctuation: /(\\.|\\\\)/\n\t\t}\n\t},\n\t'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t'boolean': /\\b(true|false)\\b/,\n\t'function': {\n\t\tpattern: /[a-z0-9_]+\\(/i,\n\t\tinside: {\n\t\t\tpunctuation: /\\(/\n\t\t}\n\t},\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/,\n\t'operator': /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|~|\\^|%/,\n\t'ignore': /&(lt|gt|amp);/i,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n;\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'keyword': /\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\\b/,\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|-?Infinity)\\b/,\n\t'function': /(?!\\d)[a-z0-9_$]+(?=\\()/i\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\tlookbehind: true\n\t}\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'script': {\n\t\t\tpattern: /<script[\\w\\W]*?>[\\w\\W]*?<\\/script>/i,\n\t\t\tinside: {\n\t\t\t\t'tag': {\n\t\t\t\t\tpattern: /<script[\\w\\W]*?>|<\\/script>/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.javascript\n\t\t\t},\n\t\t\talias: 'language-javascript'\n\t\t}\n\t});\n}\n;\n\n//# sourceURL=webpack:///./src/scripts/fabricator/prism.js?");

/***/ })

/******/ });